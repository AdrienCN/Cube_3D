#include "h_cube.h"


#define KEYPRESS	1L<<0
#define KEYRELEASE	1L<<1

void	ft_render_bmp_file(t_vars *vars);

int				ft_parsing_args(t_vars *vars, int argc, char **argv)
{
	if (argc < 2 || argc > 3)
	{
		printf("Usage : 1 or 2 arguments\n");
		return (1);
	}
	if (argc == 3)
	{
		if (ft_strcmp(argv[2], "--save") == 0)
		{
			vars->bmp_save = 1;
			printf("argv[2] == %s et == --save\n", argv[2]);
		}
		else
		{
			printf("Error-Format :./cube3D [map_name.cub] [--save]\n");
			return (1);
		}
	}
	else
		vars->bmp_save = 0;
	return (0);
}

int             main(int argc, char **argv)
{
	t_vars		vars;
	int			error;
	
	if (error = ft_parsing_args(&vars, argc, argv))
	{
		printf("Error in command line:");
		return (ft_error_msg(error, 0, 0));
	}
	if (error = ft_parsing_main(argv[1], &vars.cube))
	{
		printf("Error while parsing: [%s] ", argv[1]);
		return (ft_error_msg(error, 0, 1));
	}
	if (error = ft_init_game(&vars.cube, &vars))
	{
		printf("Error while intializing game: ");
		return (ft_error_msg(error, 1, 0));
	}
	
	printf("Init ok\n");

	if (vars.bmp_save)
	{
		ft_render_bmp_file(&vars);
		if (error)
			return (ft_error_msg(error, 1, 1);

		// Free bmp only stuff
	}
	else
	{

		mlx_loop_hook(vars.mlx, ft_update_screen, &vars);
		mlx_hook(vars.win, 2, KEYPRESS, ft_update_move, &vars);
		mlx_hook(vars.win, 3, KEYRELEASE, ft_reset_player, &vars);
		mlx_loop(vars.mlx);
		//Free game loop only stuff
	}

	// Free common stuff
	ft_free_mapinfo(&vars.cube);
	printf("\nmain --> return (0);\n");
	return (0);
}

void	ft_render_bmp_file(t_vars *vars)
{
	ft_cast_all_rays(vars);
	ft_render_walls(vars, vars->rays);
	ft_render_sprite(vars);
	ft_save_bmp(vars);	
	// Draw minimap + rays
	//ft_render_minimap(vars);
}

int		ft_update_screen(t_vars *vars)
{
	ft_cast_all_rays(vars);
	
	// draw 3D cube with my_mlx_pixel_put
	ft_render_walls(vars, vars->rays);

	ft_render_sprite(vars);
	
	// Draw minimap + rays
	//ft_render_minimap(vars);

	mlx_put_image_to_window(vars->mlx, vars->win, vars->img, 0, 0);
	ft_reset_sprites_visibility(vars, vars->sprite_count);
	return (0);
}


void	fucking_clean(void	*mlx, void *win)
{
	mlx_destroy_window(mlx, win);
//	mlx_destroy_display(mlx);
	free(mlx);
}
